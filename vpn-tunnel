#!/bin/bash

set -eu

# *** Configuration ***

# sshserver is a hostname, either fully qualified or a hostname
# definition in the ssh client configuration
sshserver=servi

# Options fed to openvpn
openvpn_compression='--comp-lzo adaptive'

# Group names or ids of processes whose traffic should be tunneled
# through the VPN
groups=vpntunneled

# User names or ids of processes whose traffic should be tunneled
# through the VPN (you would usually add those to one of the above
# groups instead, though)
owners=""

# (Static) network configuration for the VPN
network=192.168.200
ip_client=$network.5
ip_server=$network.1

dev=tun1

clientlocalip=$(is_if_up eth0 || is_if_up eth3 || is_if_up wlan0 \
    || is_if_up ppp0 || is_if_up usb0)

# logging options; you may want to put this in /var/log/ instead, I
# was too lazy to set up log rotate and cleaning up /root/tmp already
# regularly
logfile=/root/tmp/vpn-tunnel.log
verb="--verb 1"

# user/group to run openvpn as; also use --chroot option to an
# existing directory
usergroup="--user chrisopenvpn --group chrisopenvpn \
    --chroot /usr/share/doc/openvpn/examples/sample-config-files/"

# in an attempt to reduce the risk for the key landing on disk, use a
# tmpfs
tempfilecmd="tempfile -d /lib/init/rw/"

# End of configuration.

# ------------------------------------------------------------

# If sshserver is just a hostname, resolve it by looking it up in the
# ssh client configuration
if echo "$sshserver" | grep -F . >/dev/null; then
    fqserver="$sshserver"
else
    fqserver="`ssh_config-ref "$sshserver" hostname`"
fi

quote () {
    printf '%q' "$1"
}

# resolve groups here because iptables --gid-owner is broken

users_in_group () {
    tmp=`tempfile`
    if grep -E ^"$(quote "$1")": /etc/group > "$tmp"; then
	awk --field-separator : '{print $4}' < "$tmp" | sed 's/,/\n/g'
    fi
    rm "$tmp"
}

allowners=$(
    export LANG=C
    {
	for g in $groups; do
	    users_in_group "$g"
	done
	for u in $owners; do
	    echo "$u"
	done
    } | sort -u
)


# doing/done messages:
prev_done="-"

printdone () {
    if [ "$prev_done" != "-" ]; then
	eval "echo $prev_done."
    fi
}

=== () {
    local msg="$1"
    local done="${2-done}"

    printdone
    prev_done="$done"
    echo -en "* $msg: "
}

===. () {
    printdone
    prev_done="-"
    echo OK.
}

init () {
    === "getting server-side IP of DNS server" '"$serversidednsserver"'
    serversidednsserver=${serversidednsserver-"$(ssh "$sshserver" \
	'grep ^nameserver /etc/resolv.conf|awk '\''{print $2}'\''|head -1')"}

}


usage () {
    set +x
    echo "usage: $0 start|stop|restart"
    exit 1
}

# openvpn invocations ('returning' bash code): (These can be fed a
# fake value that will override variables that are not known in stop
# invocations, for the purpose of generating a stable hash value for
# daemonize.)

openvpn_invocation_client () {
    local keyfile_client="${1-"$keyfile_client"}"
    echo "openvpn $openvpn_compression --remote "$fqserver" --dev $dev " \
	"--ifconfig $(quote "$ip_client") $(quote "$ip_server") $verb " \
	"--secret $(quote "$keyfile_client") $usergroup"
}

openvpn_invocation_server () {
    local keyfile_server="${1-"$keyfile_server"}"
    echo "openvpn $openvpn_compression --float --dev $dev " \
	"--ifconfig $(quote "$ip_server") $(quote "$ip_client") $verb " \
	"--secret $(quote "$keyfile_server") $usergroup"
}


# The code generated by masq_code is run on the *server*

masq_code_() {
    echo "iptables -t nat \"$1\" POSTROUTING -p all \\"
    echo   "-s \"$2\" \\! -d \"$2\" -j MASQUERADE"
}

masq_code() {
    masq_code_ "$1" "$ip_client"
}

iptables_AD_what_ids () {
    local AD="$1"
    local what="$2"
    local ids="$3"
    for owner in $ids; do
	# make all packets of that owner go through the VPN:
	# (matching ip calls below, "table 1")
	iptables -t mangle "$AD" OUTPUT -m owner --"$what"-owner $owner \
	    -j MARK --set-mark 0x1
	
	# make their source ip that of the local end of the VPN:
	iptables -t nat "$AD" POSTROUTING -m owner --"$what"-owner $owner \
	    -j SNAT --to-source "$ip_client"
	
	# NAT DNS so that it won't go to the dns server of the local net,
	# but one in the remote net:
	iptables -t nat "$AD" OUTPUT -p udp -m owner --"$what"-owner $owner --dport 53 \
	    -j DNAT --to-destination "$serversidednsserver"
	iptables -t nat "$AD" OUTPUT -p tcp -m owner --"$what"-owner $owner --dport 53 \
	    -j DNAT --to-destination "$serversidednsserver"
    done
}

start () {
    #set -x
    init
    
    modprobe tun
    # not sure whether these are needed?:
    modprobe nf_conntrack_sip
    modprobe nf_nat_sip
    
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    keyfile_client=`$tempfilecmd`

    === "generating key"
    openvpn --genkey --secret "$keyfile_client"

    === "copying key to server\n" -
    keyfile_server=$(ssh root@"$sshserver" "$tempfilecmd")

    scp -p "$keyfile_client" root@"$sshserver":"$keyfile_server"
    
    === "starting local openvpn instance" -
    # (amazingly, set -e is in effect within the eval)
    eval "daemonize --out $(quote "$logfile") --bg --no-nice \\
        --hash-input $(quote "$(openvpn_invocation_client stable)") \\
        $(openvpn_invocation_client)"

    === "starting remote openvpn instance" -
    ssh "$sshserver" 'set -eu
        modprobe tun
	modprobe nf_conntrack_sip
	modprobe nf_nat_sip
        echo 1 > /proc/sys/net/ipv4/ip_forward
        '"daemonize --out $(quote "$logfile") --bg --no-nice \\
	--hash-input $(quote "$(openvpn_invocation_server stable)") \\
	$(openvpn_invocation_server)"'
	'"$(masq_code -A)"'
	'

    === "setting up routing on the client"
    
    route add -net "$network.0" netmask 255.255.255.0 gw "$ip_server"

    iptables_AD_what_ids -A uid "$allowners"

    ip route add default via "$ip_server" table 1
    ip rule add fwmark 1 lookup 1
    # ! don't forget to add cleanup in stop procedure for things you add here !
    
    === "wait until started"

    # remove keyfiles quickly (they won't be accessible by the openvpn
    # binary after chroot anyway)
    i=20
    ok=0
    while [ "$i" -gt 0 ]; do
	if ping -q -w1 "$ip_server" > /dev/null; then
	    ok=1
	    i=0 #our [only] way to break, right??
	else
	    sleep 1
	    i=$(( $i - 1 ))
	fi
    done
    if [ "$ok" -eq 1 ]; then

	=== cleanup
	rm -f "$keyfile_client"
	ssh "$sshserver" "rm -f \"$keyfile_server\""

	===.
    else
	false
    fi
}

stop () {
    #set -x
    if ssh "$sshserver" "echo nothing" > /dev/null; then
	# note: can't write 'init || true' here, as that would disable
	# the effect of 'set -e' within the init function. Bash is
	# weird?
	init
    fi

    === "remove iptables routing entries"
    iptables_AD_what_ids -D uid "$allowners" || true

    ip rule del fwmark 1 lookup 1 || true

    === "stop openvpn on client"
    eval "daemonize --stop \\
        --hash-input $(quote "$(openvpn_invocation_client stable)") \\
	fakecmd" || true

    === "stop openvpn on server"
    ssh "$sshserver" 'set -eu
        '"daemonize --stop \\
	--hash-input $(quote "$(openvpn_invocation_server stable)") \\
	fakecmd || true"'
    	'"$(masq_code -D)"' || true
	' || true

    ===.
}


if [ $# -ne 1 ]; then
    usage
fi
	
case "$1" in
    start)
      start;;
    stop)
      stop;;
    restart_if_running)
      # always ok?
      stop
      start;;
    restart)
      stop || true
      start;;
    *)
      usage;;
esac
