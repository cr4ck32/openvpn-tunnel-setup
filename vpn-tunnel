#!/bin/bash

set -eu

# *** Configuration ***

# sshserver is a hostname, either fully qualified or a hostname
# definition in the ssh client configuration
sshserver=servi

# Options fed to openvpn
opt_compression='--comp-lzo adaptive'

# Traffic of processes of which uids should be tunneled through the
# VPN (XX: I suppose this could be changed to group based routing)
case "`hostname`" in
    novo)
    owners="1004 1010 2007"
    # chrisekiga, [X in chroot], chrisirc
    ;;
    tie)
    owners="chris chrissbx christwinkle chrisirc chrisskype"
    ;;
    *)
    echo "missing owners setting for host '`hostname`' in $0"
    exit 1
esac

# (Static) network configuration for the VPN
network=192.168.200
ip_in_client=$network.5
ip_in_server=$network.1

dev=tun1

clientlocalip=$(is_if_up eth0 || is_if_up eth3 || is_if_up wlan0 \
    || is_if_up ppp0 || is_if_up usb0)

# logging options; you may want to put this in /var/log/ instead, I
# was too lazy to set up log rotate and cleaning up /root/tmp already
# regularly
logfile=/root/tmp/vpn-tunnel.log
verb="--verb 1"

# user/group to run openvpn as; also use --chroot option to an
# existing directory
usergroup="--user chrisopenvpn --group chrisopenvpn \
    --chroot /usr/share/doc/openvpn/examples/sample-config-files/"

# in an attempt to reduce the risk for the key landing on disk, use a
# tmpfs
tempfilecmd="tempfile -d /lib/init/rw/"

# End of configuration.

# ------------------------------------------------------------

# If sshserver is just a hostname, resolve it by looking it up in the
# ssh client configuration
if echo "$sshserver" | grep -F . >/dev/null; then
    fqserver="$sshserver"
else
    fqserver="`ssh_config-ref "$sshserver" hostname`"
fi


init () {
    client=${client-"$(ssh "$sshserver" \
	'echo "$SSH_CONNECTION"'|perl -wne 'm/^((?:\d{1,3}\.){3}\d{1,3})\s/ or die; print $1')"}

    serversidednsserver=${serversidednsserver-"$(ssh "$sshserver" \
	'grep ^nameserver /etc/resolv.conf|awk '\''{print $2}'\''|head -1')"}
}


usage () {
    set +x
    echo "usage: $0 start|stop|restart"
    exit 1
}


# The code generated by masq_code is run on the *server*

masq_code_() {
    echo "iptables -t nat \"$1\" POSTROUTING -p all \\"
    echo   "-s \"$2\" \\! -d \"$2\" -j MASQUERADE"
}

masq_code() {
    masq_code_ "$1" "$ip_in_client"
}

start () {
    #set -x
    init
    
    keyfile_client=`$tempfilecmd`

    openvpn --genkey --secret "$keyfile_client"

    keyfile_server=$(ssh root@"$sshserver" "$tempfilecmd")

    scp -p "$keyfile_client" root@"$sshserver":"$keyfile_server"
    
    modprobe tun
    # not sure whether these are needed?:
    modprobe nf_conntrack_sip
    modprobe nf_nat_sip
    
    echo 1 > /proc/sys/net/ipv4/ip_forward

    daemonize --out "$logfile" --bg --no-nice \
	openvpn $opt_compression --remote "$fqserver" --dev $dev \
	--ifconfig "$ip_in_client" "$ip_in_server" $verb \
	--secret "$keyfile_client" $usergroup
    
    ssh "$sshserver" 'set -eu
        modprobe tun
	modprobe nf_conntrack_sip
	modprobe nf_nat_sip
        echo 1 > /proc/sys/net/ipv4/ip_forward
        '"daemonize --out \"$logfile\" --bg --no-nice \\
	openvpn $opt_compression --remote \"$client\" --float --dev $dev \\
	--ifconfig \"$ip_in_server\" \"$ip_in_client\" $verb \\
	--secret \"$keyfile_server\" $usergroup"'
	'"$(masq_code -A)"'
	'
	##todo correct quoting.well escaping.

    # ** Routing on the client **
    route add -net $network.0 netmask 255.255.255.0 gw $ip_in_server

    for owner in $owners; do
	# make all packets of that owner go through the VPN:
	# (matching ip calls below, "table 1")
	iptables -t mangle -A OUTPUT -m owner --uid-owner $owner \
	    -j MARK --set-mark 0x1
	
	# make their source ip that of the local end of the VPN:
	iptables -t nat -A POSTROUTING -m owner --uid-owner $owner -p udp \
	    -j SNAT --to-source "$ip_in_client"
	iptables -t nat -A POSTROUTING -m owner --uid-owner $owner -p tcp \
	    -j SNAT --to-source "$ip_in_client"
	
	# NAT DNS so that it won't go to the dns server of the local net,
	# but one in the remote net:
	iptables -t nat -A OUTPUT -p udp -m owner --uid-owner $owner --dport 53 \
	    -j DNAT --to-destination "$serversidednsserver"
	iptables -t nat -A OUTPUT -p tcp -m owner --uid-owner $owner --dport 53 \
	    -j DNAT --to-destination "$serversidednsserver"
    done
    
    ip route add default via "$ip_in_server" table 1
    ip rule add fwmark 1 lookup 1
    # ! don't forget to add cleanup in stop procedure for things you add here !
    
    # ** Cleanup **

    # remove keyfiles quickly (they won't be accessible by the openvpn
    # binary after chroot anyway)
    i=20
    ok=0
    while [ "$i" -gt 0 ]; do
	if ping -q -w1 "$ip_in_server" > /dev/null; then
	    ok=1
	    i=0 #our [only] way to break, right??
	else
	    sleep 1
	    i=$(( $i - 1 ))
	fi
    done
    if [ "$ok" -eq 1 ]; then
	rm -f "$keyfile_client"
	ssh "$sshserver" "rm -f \"$keyfile_server\""

	echo OK.
    else
	false
    fi
}

stop () {
    #set -x
    if ssh "$sshserver" "echo nothing" > /dev/null; then
	# note: can't write 'init || true' here, as that would disable
	# the effect of 'set -e' within the init function. Bash is
	# weird?
	init
    fi

    for owner in $owners; do
	iptables -t mangle -D OUTPUT -m owner --uid-owner $owner \
	    -j MARK --set-mark 0x1 || true
	iptables -t nat -D POSTROUTING -m owner --uid-owner $owner -p udp \
	    -j SNAT --to-source "$ip_in_client" || true
	iptables -t nat -D POSTROUTING -m owner --uid-owner $owner -p tcp \
	    -j SNAT --to-source "$ip_in_client" || true
	iptables -t nat -D OUTPUT -p udp -m owner --uid-owner $owner --dport 53 \
	    -j DNAT --to-destination "$serversidednsserver" || true
	iptables -t nat -D OUTPUT -p tcp -m owner --uid-owner $owner --dport 53 \
	    -j DNAT --to-destination "$serversidednsserver" || true
    done
    ip rule del fwmark 1 lookup 1 || true
    
    # XXX Do something better?
    killall openvpn || true
    ssh "$sshserver" 'killall openvpn || true;
    	'"$(masq_code -D)"' || true
	' || true

    echo OK.
}


if [ $# -ne 1 ]; then
    usage
fi
	
case "$1" in
    start)
      start;;
    stop)
      stop;;
    restart_if_running)
      # always ok?
      stop
      start;;
    restart)
      stop || true
      start;;
    *)
      usage;;
esac
