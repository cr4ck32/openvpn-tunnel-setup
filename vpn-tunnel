#!/bin/bash

set -eu

# *** Configuration ***

# sshserver is a hostname, either fully qualified or a hostname
# definition in the ssh client configuration
sshserver=servi

# Options fed to openvpn
openvpn_compression='--comp-lzo adaptive'

# (Static) network configuration for the VPN
network=192.168.200
ip_client=$network.5
ip_server=$network.1

dev=tun1

# logging options; you may want to put this in /var/log/ instead, I
# was too lazy to set up log rotate and cleaning up /root/tmp already
# regularly
logfile=/root/tmp/vpn-tunnel.log
verb="--verb 1"

# user/group to run openvpn as; also use --chroot option to an
# existing directory
usergroup="--user chrisopenvpn --group chrisopenvpn \
    --chroot /usr/share/doc/openvpn/examples/sample-config-files/"

# in an attempt to reduce the risk for the key landing on disk, use a
# tmpfs
tempfilecmd="tempfile -d /lib/init/rw/"

# End of configuration.

# ------------------------------------------------------------

# If sshserver is just a hostname, resolve it by looking it up in the
# ssh client configuration
if echo "$sshserver" | grep -F . >/dev/null; then
    fqserver="$sshserver"
else
    fqserver="`ssh_config-ref "$sshserver" hostname`"
fi

quote () {
    printf '%q' "$1"
}


# doing/done messages:
prev_done="-"

printdone () {
    if [ "$prev_done" != "-" ]; then
	eval "echo $prev_done."
    fi
}

=== () {
    local msg="$1"
    local done="${2-done}"

    printdone
    prev_done="$done"
    echo -en "* $msg: "
}

===. () {
    printdone
    prev_done="-"
    echo OK.
}

init () {
    === "getting server-side IP of DNS server" '"$serversidednsserver"'
    serversidednsserver=${serversidednsserver-"$(ssh "$sshserver" \
	'grep ^nameserver /etc/resolv.conf|awk '\''{print $2}'\''|head -1')"}

}


usage () {
    set +x
    echo "usage: $0 start|stop|restart"
    exit 1
}

# openvpn invocations ('returning' bash code): (These can be fed a
# fake value that will override variables that are not known in stop
# invocations, for the purpose of generating a stable hash value for
# daemonize.)

openvpn_invocation_client () {
    local keyfile_client="${1-"$keyfile_client"}"
    echo "openvpn $openvpn_compression --remote "$fqserver" --dev $dev " \
	"--ifconfig $(quote "$ip_client") $(quote "$ip_server") $verb " \
	"--secret $(quote "$keyfile_client") $usergroup"
}

openvpn_invocation_server () {
    local keyfile_server="${1-"$keyfile_server"}"
    echo "openvpn $openvpn_compression --float --dev $dev " \
	"--ifconfig $(quote "$ip_server") $(quote "$ip_client") $verb " \
	"--secret $(quote "$keyfile_server") $usergroup"
}


# The code generated by masq_code is run on the *server*

masq_code_() {
    echo "iptables -t nat \"$1\" POSTROUTING -p all \\"
    echo   "-s \"$2\" \\! -d \"$2\" -j MASQUERADE"
}

masq_code() {
    masq_code_ "$1" "$ip_client"
}


# rules matching exceptional traffic that should *not* go through the
# VPN:
iptables_AD () {
    local AD="$1"
    # DHCP
    iptables -t mangle "$AD" OUTPUT -p udp --dport 67 \
	-j MARK --set-mark 0x1
    # XX: ssh, so that tearing down the tunnel will easily work, for
    # now
    iptables -t mangle "$AD" OUTPUT -p tcp --dport 22 \
	-j MARK --set-mark 0x1
}

#çXXX don't forget DNS  copy  of resolv.conf.


start () {
    #set -x
    init
    
    modprobe tun
    # not sure whether these are needed?:
    modprobe nf_conntrack_sip
    modprobe nf_nat_sip
    
    echo 1 > /proc/sys/net/ipv4/ip_forward
    
    keyfile_client=`$tempfilecmd`

    === "generating key"
    openvpn --genkey --secret "$keyfile_client"

    === "copying key to server\n" -
    keyfile_server=$(ssh root@"$sshserver" "$tempfilecmd")

    scp -p "$keyfile_client" root@"$sshserver":"$keyfile_server"
    
    === "starting local openvpn instance" -
    # (amazingly, set -e is in effect within the eval)
    eval "daemonize --out $(quote "$logfile") --bg --no-nice \\
        --hash-input $(quote "$(openvpn_invocation_client stable)") \\
        $(openvpn_invocation_client)"

    === "starting remote openvpn instance" -
    ssh "$sshserver" 'set -eu
        modprobe tun
	modprobe nf_conntrack_sip
	modprobe nf_nat_sip
        echo 1 > /proc/sys/net/ipv4/ip_forward
        '"daemonize --out $(quote "$logfile") --bg --no-nice \\
	--hash-input $(quote "$(openvpn_invocation_server stable)") \\
	$(openvpn_invocation_server)"'
	'"$(masq_code -A)"'
	'

    === "setting up routing on the client"
    # ! don't forget to add cleanup in stop procedure for things you add here !

    # remove previous default route and replace it with a default
    # route through the VPN
    dfltroute=`ip route list | grep ^default`
    ip route del $dfltroute
    ip route add default via "$ip_server"

    # but re-add previous default route for the exceptional traffic
    # marked by iptables_AD
    ip route add $dfltroute table 1
    ip rule add fwmark 1 lookup 1

    iptables_AD -A
    
    === "wait until started"

    # remove keyfiles quickly (they won't be accessible by the openvpn
    # binary after chroot anyway)
    i=20
    ok=0
    while [ "$i" -gt 0 ]; do
	if ping -q -w1 "$ip_server" > /dev/null; then
	    ok=1
	    i=0 #our [only] way to break, right??
	else
	    sleep 1
	    i=$(( $i - 1 ))
	fi
    done
    if [ "$ok" -eq 1 ]; then

	=== cleanup
	rm -f "$keyfile_client"
	ssh "$sshserver" "rm -f \"$keyfile_server\""

	===.
    else
	false
    fi
}

stop () {
    #set -x
    if ssh "$sshserver" "echo nothing" > /dev/null; then
	# note: can't write 'init || true' here, as that would disable
	# the effect of 'set -e' within the init function. Bash is
	# weird?
	init
    fi

    === "remove iptables routing entries"

    iptables_AD -D || true
    ip rule del fwmark 1 lookup 1 || true

    if dfltroute_modded=`ip route list | egrep '^default.*table 1\b'`; then
	ip route del $dfltroute_modded
	dfltroute_orig=`echo "$dfltroute_modded" | sed 's/table 1//'`
	ip route add $dfltroute_orig
    fi


    === "stop openvpn on client"
    eval "daemonize --stop \\
        --hash-input $(quote "$(openvpn_invocation_client stable)") \\
	fakecmd" || true

    === "stop openvpn on server"
    ssh "$sshserver" 'set -eu
        '"daemonize --stop \\
	--hash-input $(quote "$(openvpn_invocation_server stable)") \\
	fakecmd || true"'
    	'"$(masq_code -D)"' || true
	' || true

    ===.
}


if [ $# -ne 1 ]; then
    usage
fi
	
case "$1" in
    start)
      start;;
    stop)
      stop;;
    restart_if_running)
      # always ok?
      stop
      start;;
    restart)
      stop || true
      start;;
    *)
      usage;;
esac
